asset contract Node {
    asset state NodeNull {}
    asset state NodeSome {
        Transport@Shared node;
    }

    Node@NodeSome(Transport@Shared node) {
        ->NodeSome(node = node);
    }

    Node@NodeNull() {
        ->NodeNull;
    }


    transaction getNode(Node@NodeSome this) returns Transport@Shared
    {
        return node;
    }

    transaction getValue(string fieldName, Node@NodeSome this) returns string {
        string ret;
        if (fieldName == "name") {
            ret = node.getName();
        } else {
            if (fieldName == "originPort") {
                ret = node.getOriginPort();
            } else {
                if (fieldName == "transportType") {
                    ret = node.getTransportType();
                }
            }
        }
        return ret;
    }

    transaction getNext(Transport t) returns Node {
            return t.next;
    }

    transaction appendNode(Transport t, Transport tNew) {
            // traverse list
            // last object is of type NodeNull,
            // populate Transport fields,
            // move to NodeSome state,
            // and create a new NodeNull object
            switch getNext(t) {
                case NodeSome {
                    t.next.getNode().appendNode(t.Next, tNew);
                }
                case NodeNull {
                    ->NodeSome(node = tNew);
                }
            }
    }
}


asset contract Transport {
    string name;
    string transportType;
    string originPort;
    Node@Owned next;

    Transport@Owned(string name, string transportType, string originPort) {
        this.name = name;
        this.transportType = transportType;
        this.originPort = originPort;
        this.next = new Node();
    }

    transaction getName(Transport this) returns string {
        return this.name;
    }

    transaction getTransportType(Transport this) returns string {
        return this.transportType;
    }

    transaction getOriginPort(Transport this) returns string {
        return this.originPort;
    }

    transaction length(Transport@Unowned this) returns int {
        int i = 1;
        switch next {
            case NodeSome {
                i = i + next.getNode().length();
            }
        }
        return i;
    }

    transaction nth(int n) returns Node@Unowned {
        if (n == 0) {
            return new Node(this);
        }
        // the following seems ok
        switch next {
            case NodeSome {
                return next.getNode().nth(n - 1);
            }
            case NodeNull {
                return new Node();
            }
        }
        // but the compiler complains about the following
        /* Node ret;
        switch next {
            case NodeSome {
                ret = next.getNode().nth(n - 1);
            }
            case NodeNull {
                ret = new Node();
            }
        }
        return ret;*/

    }

    transaction append(string name, string transportType, string originPort) {
        Transport@Unowned t = new Transport(name, transportType, originPort);
        this.next.appendNode(this, t);

       /* switch next {
            case NodeSome {
                next.getNode().append(name, transportType, originPort);
            }
            case NodeNull {
                //next = new Node(new Transport(name, transportType, originPort));

            }
        } */
    }


}
